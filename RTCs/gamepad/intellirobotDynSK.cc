// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "intellirobot.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_RTC_mTime[] = {
  {"sec", CORBA::TypeCode::PR_ulong_tc()},
  {"nsec", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTime
#  undef _0RL_tc_RTC_mTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTime = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Time:1.0", "Time", _0RL_structmember_RTC_mTime, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mTimedVelocity[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"v", CORBA::TypeCode::PR_double_tc()},
  {"w", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mTimedVelocity
#  undef _0RL_tc_RTC_mTimedVelocity
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedVelocity = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedVelocity:1.0", "TimedVelocity", _0RL_structmember_RTC_mTimedVelocity, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedVelocity = _0RL_tc_RTC_mTimedVelocity;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedVelocity = _0RL_tc_RTC_mTimedVelocity;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedOdometry[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"theta", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mTimedOdometry
#  undef _0RL_tc_RTC_mTimedOdometry
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedOdometry = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedOdometry:1.0", "TimedOdometry", _0RL_structmember_RTC_mTimedOdometry, 4, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedOdometry = _0RL_tc_RTC_mTimedOdometry;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedOdometry = _0RL_tc_RTC_mTimedOdometry;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedLongSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedLongSeq
#  undef _0RL_tc_RTC_mTimedLongSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedLongSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedLongSeq:1.0", "TimedLongSeq", _0RL_structmember_RTC_mTimedLongSeq, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mTimedScan[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"scan", _0RL_tc_RTC_mTimedLongSeq}
};

#ifdef _0RL_tc_RTC_mTimedScan
#  undef _0RL_tc_RTC_mTimedScan
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedScan = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedScan:1.0", "TimedScan", _0RL_structmember_RTC_mTimedScan, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedScan = _0RL_tc_RTC_mTimedScan;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedScan = _0RL_tc_RTC_mTimedScan;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mPath[] = {
  {"type", CORBA::TypeCode::PR_short_tc()},
  {"coordinate", CORBA::TypeCode::PR_short_tc()},
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"theta", CORBA::TypeCode::PR_double_tc()},
  {"v", CORBA::TypeCode::PR_double_tc()},
  {"w", CORBA::TypeCode::PR_double_tc()},
  {"r", CORBA::TypeCode::PR_double_tc()},
  {"tm", _0RL_tc_RTC_mTime}
};

#ifdef _0RL_tc_RTC_mPath
#  undef _0RL_tc_RTC_mPath
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPath = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Path:1.0", "Path", _0RL_structmember_RTC_mPath, 9, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Path = _0RL_tc_RTC_mPath;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Path = _0RL_tc_RTC_mPath;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mPathSeq[] = {
  {"path_list", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mPath, &_0RL_tcTrack)},
  {"tm", _0RL_tc_RTC_mTime}
};

#ifdef _0RL_tc_RTC_mPathSeq
#  undef _0RL_tc_RTC_mPathSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPathSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PathSeq:1.0", "PathSeq", _0RL_structmember_RTC_mPathSeq, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PathSeq = _0RL_tc_RTC_mPathSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PathSeq = _0RL_tc_RTC_mPathSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedObstacle[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"r", CORBA::TypeCode::PR_double_tc()},
  {"tm", _0RL_tc_RTC_mTime}
};

#ifdef _0RL_tc_RTC_mTimedObstacle
#  undef _0RL_tc_RTC_mTimedObstacle
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedObstacle = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedObstacle:1.0", "TimedObstacle", _0RL_structmember_RTC_mTimedObstacle, 4, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedObstacle = _0RL_tc_RTC_mTimedObstacle;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedObstacle = _0RL_tc_RTC_mTimedObstacle;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedMovingObstacle[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"r", CORBA::TypeCode::PR_double_tc()},
  {"theta", CORBA::TypeCode::PR_double_tc()},
  {"vel", CORBA::TypeCode::PR_double_tc()},
  {"tm", _0RL_tc_RTC_mTime}
};

#ifdef _0RL_tc_RTC_mTimedMovingObstacle
#  undef _0RL_tc_RTC_mTimedMovingObstacle
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedMovingObstacle = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedMovingObstacle:1.0", "TimedMovingObstacle", _0RL_structmember_RTC_mTimedMovingObstacle, 6, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedMovingObstacle = _0RL_tc_RTC_mTimedMovingObstacle;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedMovingObstacle = _0RL_tc_RTC_mTimedMovingObstacle;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mTimedObstacles[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"obstacles", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mTimedObstacle, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedObstacles
#  undef _0RL_tc_RTC_mTimedObstacles
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedObstacles = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedObstacles:1.0", "TimedObstacles", _0RL_structmember_RTC_mTimedObstacles, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedObstacles = _0RL_tc_RTC_mTimedObstacles;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedObstacles = _0RL_tc_RTC_mTimedObstacles;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mTimedMovingObstacles[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"obstacles", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mTimedMovingObstacle, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedMovingObstacles
#  undef _0RL_tc_RTC_mTimedMovingObstacles
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedMovingObstacles = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedMovingObstacles:1.0", "TimedMovingObstacles", _0RL_structmember_RTC_mTimedMovingObstacles, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedMovingObstacles = _0RL_tc_RTC_mTimedMovingObstacles;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedMovingObstacles = _0RL_tc_RTC_mTimedMovingObstacles;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mTimedParticle[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"theta", CORBA::TypeCode::PR_double_tc()},
  {"w", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mTimedParticle
#  undef _0RL_tc_RTC_mTimedParticle
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedParticle = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedParticle:1.0", "TimedParticle", _0RL_structmember_RTC_mTimedParticle, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedParticle = _0RL_tc_RTC_mTimedParticle;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedParticle = _0RL_tc_RTC_mTimedParticle;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedParticles[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"timestamp", CORBA::TypeCode::PR_double_tc()},
  {"id", CORBA::TypeCode::PR_long_tc()},
  {"particles", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mTimedParticle, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedParticles
#  undef _0RL_tc_RTC_mTimedParticles
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedParticles = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedParticles:1.0", "TimedParticles", _0RL_structmember_RTC_mTimedParticles, 4, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedParticles = _0RL_tc_RTC_mTimedParticles;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedParticles = _0RL_tc_RTC_mTimedParticles;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mVelocity2D[] = {
  {"vx", CORBA::TypeCode::PR_double_tc()},
  {"vy", CORBA::TypeCode::PR_double_tc()},
  {"va", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVelocity2D
#  undef _0RL_tc_RTC_mVelocity2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVelocity2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Velocity2D:1.0", "Velocity2D", _0RL_structmember_RTC_mVelocity2D, 3, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mTimedFormationMember[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"group", CORBA::TypeCode::PR_short_tc()},
  {"shape", CORBA::TypeCode::PR_short_tc()},
  {"leader_id", CORBA::TypeCode::PR_short_tc()},
  {"input", _0RL_tc_RTC_mVelocity2D},
  {"member", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_short_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedFormationMember
#  undef _0RL_tc_RTC_mTimedFormationMember
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedFormationMember = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedFormationMember:1.0", "TimedFormationMember", _0RL_structmember_RTC_mTimedFormationMember, 6, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedFormationMember = _0RL_tc_RTC_mTimedFormationMember;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedFormationMember = _0RL_tc_RTC_mTimedFormationMember;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mPoint2D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPoint2D
#  undef _0RL_tc_RTC_mPoint2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoint2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Point2D:1.0", "Point2D", _0RL_structmember_RTC_mPoint2D, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mPose2D[] = {
  {"position", _0RL_tc_RTC_mPoint2D},
  {"heading", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPose2D
#  undef _0RL_tc_RTC_mPose2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPose2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Pose2D:1.0", "Pose2D", _0RL_structmember_RTC_mPose2D, 2, &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_RTC_mTimedFormationReference[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_short_tc()},
  {"mode", CORBA::TypeCode::PR_short_tc()},
  {"lpos", _0RL_tc_RTC_mPose2D},
  {"linput", _0RL_tc_RTC_mVelocity2D},
  {"ref_x", CORBA::TypeCode::PR_double_tc()},
  {"ref_y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mTimedFormationReference
#  undef _0RL_tc_RTC_mTimedFormationReference
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedFormationReference = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedFormationReference:1.0", "TimedFormationReference", _0RL_structmember_RTC_mTimedFormationReference, 7, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedFormationReference = _0RL_tc_RTC_mTimedFormationReference;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedFormationReference = _0RL_tc_RTC_mTimedFormationReference;
#endif






static CORBA::PR_structMember _0RL_structmember_RTC_mTimedRobotData[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_short_tc()},
  {"pos", _0RL_tc_RTC_mPose2D},
  {"vel", _0RL_tc_RTC_mVelocity2D}
};

#ifdef _0RL_tc_RTC_mTimedRobotData
#  undef _0RL_tc_RTC_mTimedRobotData
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedRobotData = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedRobotData:1.0", "TimedRobotData", _0RL_structmember_RTC_mTimedRobotData, 4, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedRobotData = _0RL_tc_RTC_mTimedRobotData;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedRobotData = _0RL_tc_RTC_mTimedRobotData;
#endif




























static CORBA::PR_structMember _0RL_structmember_RTC_mFormationReferenceSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"robot1", _0RL_tc_RTC_mTimedFormationReference},
  {"robot2", _0RL_tc_RTC_mTimedFormationReference},
  {"robot3", _0RL_tc_RTC_mTimedFormationReference},
  {"robot4", _0RL_tc_RTC_mTimedFormationReference},
  {"robot5", _0RL_tc_RTC_mTimedFormationReference}
};

#ifdef _0RL_tc_RTC_mFormationReferenceSeq
#  undef _0RL_tc_RTC_mFormationReferenceSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mFormationReferenceSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/FormationReferenceSeq:1.0", "FormationReferenceSeq", _0RL_structmember_RTC_mFormationReferenceSeq, 6, &_0RL_tcTrack);



























#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FormationReferenceSeq = _0RL_tc_RTC_mFormationReferenceSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FormationReferenceSeq = _0RL_tc_RTC_mFormationReferenceSeq;
#endif


















static CORBA::PR_structMember _0RL_structmember_RTC_mFormationMemberSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"group1", _0RL_tc_RTC_mTimedFormationMember},
  {"group2", _0RL_tc_RTC_mTimedFormationMember},
  {"group3", _0RL_tc_RTC_mTimedFormationMember},
  {"group4", _0RL_tc_RTC_mTimedFormationMember},
  {"group5", _0RL_tc_RTC_mTimedFormationMember}
};

#ifdef _0RL_tc_RTC_mFormationMemberSeq
#  undef _0RL_tc_RTC_mFormationMemberSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mFormationMemberSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/FormationMemberSeq:1.0", "FormationMemberSeq", _0RL_structmember_RTC_mFormationMemberSeq, 6, &_0RL_tcTrack);

















#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_FormationMemberSeq = _0RL_tc_RTC_mFormationMemberSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_FormationMemberSeq = _0RL_tc_RTC_mFormationMemberSeq;
#endif




























static CORBA::PR_structMember _0RL_structmember_RTC_mRobotDataSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"robot1", _0RL_tc_RTC_mTimedRobotData},
  {"robot2", _0RL_tc_RTC_mTimedRobotData},
  {"robot3", _0RL_tc_RTC_mTimedRobotData},
  {"robot4", _0RL_tc_RTC_mTimedRobotData},
  {"robot5", _0RL_tc_RTC_mTimedRobotData}
};

#ifdef _0RL_tc_RTC_mRobotDataSeq
#  undef _0RL_tc_RTC_mRobotDataSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mRobotDataSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/RobotDataSeq:1.0", "RobotDataSeq", _0RL_structmember_RTC_mRobotDataSeq, 6, &_0RL_tcTrack);



























#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RobotDataSeq = _0RL_tc_RTC_mRobotDataSeq;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RobotDataSeq = _0RL_tc_RTC_mRobotDataSeq;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mGga__message[] = {
  {"field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field09", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field10", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field11", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field12", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field13", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field14", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field15", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mGga__message
#  undef _0RL_tc_RTC_mGga__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGga__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Gga_message:1.0", "Gga_message", _0RL_structmember_RTC_mGga__message, 16, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Gga_message = _0RL_tc_RTC_mGga__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Gga_message = _0RL_tc_RTC_mGga__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mGll__message[] = {
  {"field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mGll__message
#  undef _0RL_tc_RTC_mGll__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGll__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Gll_message:1.0", "Gll_message", _0RL_structmember_RTC_mGll__message, 9, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Gll_message = _0RL_tc_RTC_mGll__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Gll_message = _0RL_tc_RTC_mGll__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mGns__message[] = {
  {"field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field09", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field10", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field11", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field12", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field11", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field12", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field11", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field12", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mGns__message
#  undef _0RL_tc_RTC_mGns__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGns__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Gns_message:1.0", "Gns_message", _0RL_structmember_RTC_mGns__message, 23, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Gns_message = _0RL_tc_RTC_mGns__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Gns_message = _0RL_tc_RTC_mGns__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mGrs__message[] = {
  {"gp_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_09", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_10", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_11", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_12", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_09", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_10", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_11", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_12", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mGrs__message
#  undef _0RL_tc_RTC_mGrs__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGrs__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Grs_message:1.0", "Grs_message", _0RL_structmember_RTC_mGrs__message, 32, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Grs_message = _0RL_tc_RTC_mGrs__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Grs_message = _0RL_tc_RTC_mGrs__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mGsa__message[] = {
  {"gp_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_09", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_10", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_11", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field03_12", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp_field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_09", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_10", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_11", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field03_12", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl_field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mGsa__message
#  undef _0RL_tc_RTC_mGsa__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGsa__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Gsa_message:1.0", "Gsa_message", _0RL_structmember_RTC_mGsa__message, 38, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Gsa_message = _0RL_tc_RTC_mGsa__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Gsa_message = _0RL_tc_RTC_mGsa__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mGst__message[] = {
  {"field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field09", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mGst__message
#  undef _0RL_tc_RTC_mGst__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGst__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Gst_message:1.0", "Gst_message", _0RL_structmember_RTC_mGst__message, 10, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Gst_message = _0RL_tc_RTC_mGst__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Gst_message = _0RL_tc_RTC_mGst__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mGsv__message[] = {
  {"gp1_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_1_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_1_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_1_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_1_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_2_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_2_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_2_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_2_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_3_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_3_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_3_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_3_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_4_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_4_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_4_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field04_4_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp1_field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_1_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_1_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_1_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_1_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_2_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_2_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_2_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_2_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_3_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_3_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_3_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_3_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_4_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_4_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_4_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field04_4_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp2_field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_1_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_1_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_1_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_1_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_2_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_2_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_2_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_2_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_3_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_3_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_3_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_3_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_4_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_4_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_4_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field04_4_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gp3_field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_1_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_1_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_1_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_1_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_2_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_2_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_2_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_2_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_3_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_3_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_3_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_3_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_4_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_4_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_4_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field04_4_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl1_field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_1_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_1_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_1_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_1_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_2_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_2_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_2_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_2_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_3_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_3_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_3_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_3_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_4_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_4_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_4_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field04_4_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl2_field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_1_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_1_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_1_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_1_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_2_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_2_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_2_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_2_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_3_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_3_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_3_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_3_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_4_1", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_4_2", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_4_3", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field04_4_4", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"gl3_field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mGsv__message
#  undef _0RL_tc_RTC_mGsv__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGsv__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Gsv_message:1.0", "Gsv_message", _0RL_structmember_RTC_mGsv__message, 126, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Gsv_message = _0RL_tc_RTC_mGsv__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Gsv_message = _0RL_tc_RTC_mGsv__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mHdt__message[] = {
  {"field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mHdt__message
#  undef _0RL_tc_RTC_mHdt__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mHdt__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Hdt_message:1.0", "Hdt_message", _0RL_structmember_RTC_mHdt__message, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Hdt_message = _0RL_tc_RTC_mHdt__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Hdt_message = _0RL_tc_RTC_mHdt__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mRmc__message[] = {
  {"field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field09", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field10", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field11", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field12", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field13", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mRmc__message
#  undef _0RL_tc_RTC_mRmc__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mRmc__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Rmc_message:1.0", "Rmc_message", _0RL_structmember_RTC_mRmc__message, 14, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Rmc_message = _0RL_tc_RTC_mRmc__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Rmc_message = _0RL_tc_RTC_mRmc__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mVtg__message[] = {
  {"field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field08", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field09", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field10", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mVtg__message
#  undef _0RL_tc_RTC_mVtg__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVtg__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Vtg_message:1.0", "Vtg_message", _0RL_structmember_RTC_mVtg__message, 11, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Vtg_message = _0RL_tc_RTC_mVtg__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Vtg_message = _0RL_tc_RTC_mVtg__message;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mZda__message[] = {
  {"field00", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field01", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field02", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field03", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field04", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field05", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field06", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"field07", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mZda__message
#  undef _0RL_tc_RTC_mZda__message
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mZda__message = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Zda_message:1.0", "Zda_message", _0RL_structmember_RTC_mZda__message, 8, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Zda_message = _0RL_tc_RTC_mZda__message;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Zda_message = _0RL_tc_RTC_mZda__message;
#endif














static CORBA::PR_structMember _0RL_structmember_RTC_mTimedLegacyData[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"mode", CORBA::TypeCode::PR_ushort_tc()},
  {"gga", _0RL_tc_RTC_mGga__message},
  {"gll", _0RL_tc_RTC_mGll__message},
  {"gns", _0RL_tc_RTC_mGns__message},
  {"grs", _0RL_tc_RTC_mGrs__message},
  {"gsa", _0RL_tc_RTC_mGsa__message},
  {"gst", _0RL_tc_RTC_mGst__message},
  {"gsv", _0RL_tc_RTC_mGsv__message},
  {"hdt", _0RL_tc_RTC_mHdt__message},
  {"rmc", _0RL_tc_RTC_mRmc__message},
  {"vtg", _0RL_tc_RTC_mVtg__message},
  {"zda", _0RL_tc_RTC_mZda__message}
};

#ifdef _0RL_tc_RTC_mTimedLegacyData
#  undef _0RL_tc_RTC_mTimedLegacyData
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedLegacyData = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedLegacyData:1.0", "TimedLegacyData", _0RL_structmember_RTC_mTimedLegacyData, 13, &_0RL_tcTrack);













#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedLegacyData = _0RL_tc_RTC_mTimedLegacyData;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedLegacyData = _0RL_tc_RTC_mTimedLegacyData;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedJgd2000Position[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"latitude", CORBA::TypeCode::PR_double_tc()},
  {"longitude", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mTimedJgd2000Position
#  undef _0RL_tc_RTC_mTimedJgd2000Position
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedJgd2000Position = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedJgd2000Position:1.0", "TimedJgd2000Position", _0RL_structmember_RTC_mTimedJgd2000Position, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedJgd2000Position = _0RL_tc_RTC_mTimedJgd2000Position;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedJgd2000Position = _0RL_tc_RTC_mTimedJgd2000Position;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mTimedGpsData[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"Jgd2000Position", _0RL_tc_RTC_mTimedJgd2000Position}
};

#ifdef _0RL_tc_RTC_mTimedGpsData
#  undef _0RL_tc_RTC_mTimedGpsData
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedGpsData = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedGpsData:1.0", "TimedGpsData", _0RL_structmember_RTC_mTimedGpsData, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedGpsData = _0RL_tc_RTC_mTimedGpsData;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedGpsData = _0RL_tc_RTC_mTimedGpsData;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimed19Position[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mTimed19Position
#  undef _0RL_tc_RTC_mTimed19Position
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimed19Position = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Timed19Position:1.0", "Timed19Position", _0RL_structmember_RTC_mTimed19Position, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Timed19Position = _0RL_tc_RTC_mTimed19Position;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Timed19Position = _0RL_tc_RTC_mTimed19Position;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedRobotPosition[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mTimedRobotPosition
#  undef _0RL_tc_RTC_mTimedRobotPosition
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedRobotPosition = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedRobotPosition:1.0", "TimedRobotPosition", _0RL_structmember_RTC_mTimedRobotPosition, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedRobotPosition = _0RL_tc_RTC_mTimedRobotPosition;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedRobotPosition = _0RL_tc_RTC_mTimedRobotPosition;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedMapData[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"mode", CORBA::TypeCode::PR_ushort_tc()},
  {"location", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"mapset", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"type", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"origin_x", CORBA::TypeCode::PR_long_tc()},
  {"origin_y", CORBA::TypeCode::PR_long_tc()},
  {"size_x", CORBA::TypeCode::PR_ulong_tc()},
  {"size_y", CORBA::TypeCode::PR_ulong_tc()},
  {"explanation", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"map_origin_x", CORBA::TypeCode::PR_long_tc()},
  {"map_origin_y", CORBA::TypeCode::PR_long_tc()},
  {"map_size_x", CORBA::TypeCode::PR_ulong_tc()},
  {"map_size_y", CORBA::TypeCode::PR_ulong_tc()},
  {"pixel_size_x", CORBA::TypeCode::PR_ulong_tc()},
  {"pixel_size_y", CORBA::TypeCode::PR_ulong_tc()},
  {"category", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"mapdata", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ulong_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedMapData
#  undef _0RL_tc_RTC_mTimedMapData
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedMapData = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedMapData:1.0", "TimedMapData", _0RL_structmember_RTC_mTimedMapData, 18, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedMapData = _0RL_tc_RTC_mTimedMapData;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedMapData = _0RL_tc_RTC_mTimedMapData;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mArc[] = {
  {"start_id", CORBA::TypeCode::PR_ulong_tc()},
  {"end_id", CORBA::TypeCode::PR_ulong_tc()},
  {"cost", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mArc
#  undef _0RL_tc_RTC_mArc
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mArc = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Arc:1.0", "Arc", _0RL_structmember_RTC_mArc, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Arc = _0RL_tc_RTC_mArc;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Arc = _0RL_tc_RTC_mArc;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mNode[] = {
  {"id", CORBA::TypeCode::PR_ulong_tc()},
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"theta", CORBA::TypeCode::PR_double_tc()},
  {"explanation", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mNode
#  undef _0RL_tc_RTC_mNode
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mNode = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Node:1.0", "Node", _0RL_structmember_RTC_mNode, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Node = _0RL_tc_RTC_mNode;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Node = _0RL_tc_RTC_mNode;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mTimedArcNode[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"arc_data", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mArc, &_0RL_tcTrack)},
  {"node_data", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mNode, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedArcNode
#  undef _0RL_tc_RTC_mTimedArcNode
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedArcNode = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedArcNode:1.0", "TimedArcNode", _0RL_structmember_RTC_mTimedArcNode, 3, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedArcNode = _0RL_tc_RTC_mTimedArcNode;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedArcNode = _0RL_tc_RTC_mTimedArcNode;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mLine[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"theta", CORBA::TypeCode::PR_double_tc()},
  {"r", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mLine
#  undef _0RL_tc_RTC_mLine
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mLine = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Line:1.0", "Line", _0RL_structmember_RTC_mLine, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Line = _0RL_tc_RTC_mLine;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Line = _0RL_tc_RTC_mLine;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mCircle[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"r", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mCircle
#  undef _0RL_tc_RTC_mCircle
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mCircle = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Circle:1.0", "Circle", _0RL_structmember_RTC_mCircle, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Circle = _0RL_tc_RTC_mCircle;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Circle = _0RL_tc_RTC_mCircle;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mTimedLandmark[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"line_data", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mLine, &_0RL_tcTrack)},
  {"circle_data", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mCircle, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedLandmark
#  undef _0RL_tc_RTC_mTimedLandmark
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedLandmark = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedLandmark:1.0", "TimedLandmark", _0RL_structmember_RTC_mTimedLandmark, 3, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedLandmark = _0RL_tc_RTC_mTimedLandmark;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedLandmark = _0RL_tc_RTC_mTimedLandmark;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedMapOrder[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"trigger", CORBA::TypeCode::PR_ushort_tc()},
  {"mode", CORBA::TypeCode::PR_ushort_tc()},
  {"location", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"mapset", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"type", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"origin_x", CORBA::TypeCode::PR_long_tc()},
  {"origin_y", CORBA::TypeCode::PR_long_tc()},
  {"size_x", CORBA::TypeCode::PR_ulong_tc()},
  {"size_y", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTimedMapOrder
#  undef _0RL_tc_RTC_mTimedMapOrder
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedMapOrder = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedMapOrder:1.0", "TimedMapOrder", _0RL_structmember_RTC_mTimedMapOrder, 10, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedMapOrder = _0RL_tc_RTC_mTimedMapOrder;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedMapOrder = _0RL_tc_RTC_mTimedMapOrder;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mRobotPosition[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mRobotPosition
#  undef _0RL_tc_RTC_mRobotPosition
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mRobotPosition = CORBA::TypeCode::PR_struct_tc("IDL:RTC/RobotPosition:1.0", "RobotPosition", _0RL_structmember_RTC_mRobotPosition, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RobotPosition = _0RL_tc_RTC_mRobotPosition;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RobotPosition = _0RL_tc_RTC_mRobotPosition;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedPath[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"path_data", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mRobotPosition, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedPath
#  undef _0RL_tc_RTC_mTimedPath
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedPath = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedPath:1.0", "TimedPath", _0RL_structmember_RTC_mTimedPath, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedPath = _0RL_tc_RTC_mTimedPath;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedPath = _0RL_tc_RTC_mTimedPath;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mTimedMeshOrder[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"trigger", CORBA::TypeCode::PR_ushort_tc()},
  {"mode", CORBA::TypeCode::PR_ushort_tc()},
  {"location", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"mapset", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"type", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack)},
  {"origin_x", CORBA::TypeCode::PR_long_tc()},
  {"origin_y", CORBA::TypeCode::PR_long_tc()},
  {"size_x", CORBA::TypeCode::PR_ulong_tc()},
  {"size_y", CORBA::TypeCode::PR_ulong_tc()},
  {"pixel_size_x", CORBA::TypeCode::PR_ulong_tc()},
  {"pixel_size_y", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTimedMeshOrder
#  undef _0RL_tc_RTC_mTimedMeshOrder
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedMeshOrder = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedMeshOrder:1.0", "TimedMeshOrder", _0RL_structmember_RTC_mTimedMeshOrder, 12, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedMeshOrder = _0RL_tc_RTC_mTimedMeshOrder;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedMeshOrder = _0RL_tc_RTC_mTimedMeshOrder;
#endif





static CORBA::PR_structMember _0RL_structmember_IIS_mTanakaTest[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)},
  {"data", _0RL_tc_RTC_mPose2D},
  {"error", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_IIS_mTanakaTest
#  undef _0RL_tc_IIS_mTanakaTest
#endif
static CORBA::TypeCode_ptr _0RL_tc_IIS_mTanakaTest = CORBA::TypeCode::PR_struct_tc("IDL:IIS/TanakaTest:1.0", "TanakaTest", _0RL_structmember_IIS_mTanakaTest, 4, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IIS { 
  const ::CORBA::TypeCode_ptr _tc_TanakaTest = _0RL_tc_IIS_mTanakaTest;
} 
#else
const ::CORBA::TypeCode_ptr IIS::_tc_TanakaTest = _0RL_tc_IIS_mTanakaTest;
#endif



static CORBA::PR_structMember _0RL_structmember_IIS_mTimedVelocity[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)},
  {"vx", CORBA::TypeCode::PR_double_tc()},
  {"vy", CORBA::TypeCode::PR_double_tc()},
  {"w", CORBA::TypeCode::PR_double_tc()},
  {"error", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_IIS_mTimedVelocity
#  undef _0RL_tc_IIS_mTimedVelocity
#endif
static CORBA::TypeCode_ptr _0RL_tc_IIS_mTimedVelocity = CORBA::TypeCode::PR_struct_tc("IDL:IIS/TimedVelocity:1.0", "TimedVelocity", _0RL_structmember_IIS_mTimedVelocity, 6, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IIS { 
  const ::CORBA::TypeCode_ptr _tc_TimedVelocity = _0RL_tc_IIS_mTimedVelocity;
} 
#else
const ::CORBA::TypeCode_ptr IIS::_tc_TimedVelocity = _0RL_tc_IIS_mTimedVelocity;
#endif



static CORBA::PR_structMember _0RL_structmember_IIS_mTimedPosition[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)},
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"theta", CORBA::TypeCode::PR_double_tc()},
  {"error", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_IIS_mTimedPosition
#  undef _0RL_tc_IIS_mTimedPosition
#endif
static CORBA::TypeCode_ptr _0RL_tc_IIS_mTimedPosition = CORBA::TypeCode::PR_struct_tc("IDL:IIS/TimedPosition:1.0", "TimedPosition", _0RL_structmember_IIS_mTimedPosition, 6, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IIS { 
  const ::CORBA::TypeCode_ptr _tc_TimedPosition = _0RL_tc_IIS_mTimedPosition;
} 
#else
const ::CORBA::TypeCode_ptr IIS::_tc_TimedPosition = _0RL_tc_IIS_mTimedPosition;
#endif





static CORBA::PR_structMember _0RL_structmember_IIS_mTimedPose2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)},
  {"data", _0RL_tc_RTC_mPose2D},
  {"error", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_IIS_mTimedPose2D
#  undef _0RL_tc_IIS_mTimedPose2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_IIS_mTimedPose2D = CORBA::TypeCode::PR_struct_tc("IDL:IIS/TimedPose2D:1.0", "TimedPose2D", _0RL_structmember_IIS_mTimedPose2D, 4, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IIS { 
  const ::CORBA::TypeCode_ptr _tc_TimedPose2D = _0RL_tc_IIS_mTimedPose2D;
} 
#else
const ::CORBA::TypeCode_ptr IIS::_tc_TimedPose2D = _0RL_tc_IIS_mTimedPose2D;
#endif





static CORBA::PR_structMember _0RL_structmember_IIS_mTimedPose2DSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mPose2D, &_0RL_tcTrack)},
  {"error", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_IIS_mTimedPose2DSeq
#  undef _0RL_tc_IIS_mTimedPose2DSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_IIS_mTimedPose2DSeq = CORBA::TypeCode::PR_struct_tc("IDL:IIS/TimedPose2DSeq:1.0", "TimedPose2DSeq", _0RL_structmember_IIS_mTimedPose2DSeq, 4, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IIS { 
  const ::CORBA::TypeCode_ptr _tc_TimedPose2DSeq = _0RL_tc_IIS_mTimedPose2DSeq;
} 
#else
const ::CORBA::TypeCode_ptr IIS::_tc_TimedPose2DSeq = _0RL_tc_IIS_mTimedPose2DSeq;
#endif






static CORBA::PR_structMember _0RL_structmember_IIS_mTimedPath2DSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)},
  {"pose", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mPose2D, &_0RL_tcTrack)},
  {"velocity", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_RTC_mVelocity2D, &_0RL_tcTrack)},
  {"error", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_IIS_mTimedPath2DSeq
#  undef _0RL_tc_IIS_mTimedPath2DSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_IIS_mTimedPath2DSeq = CORBA::TypeCode::PR_struct_tc("IDL:IIS/TimedPath2DSeq:1.0", "TimedPath2DSeq", _0RL_structmember_IIS_mTimedPath2DSeq, 5, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IIS { 
  const ::CORBA::TypeCode_ptr _tc_TimedPath2DSeq = _0RL_tc_IIS_mTimedPath2DSeq;
} 
#else
const ::CORBA::TypeCode_ptr IIS::_tc_TimedPath2DSeq = _0RL_tc_IIS_mTimedPath2DSeq;
#endif




static CORBA::PR_structMember _0RL_structmember_IIS_mTimedVelocity2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)},
  {"data", _0RL_tc_RTC_mVelocity2D},
  {"error", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_IIS_mTimedVelocity2D
#  undef _0RL_tc_IIS_mTimedVelocity2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_IIS_mTimedVelocity2D = CORBA::TypeCode::PR_struct_tc("IDL:IIS/TimedVelocity2D:1.0", "TimedVelocity2D", _0RL_structmember_IIS_mTimedVelocity2D, 4, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IIS { 
  const ::CORBA::TypeCode_ptr _tc_TimedVelocity2D = _0RL_tc_IIS_mTimedVelocity2D;
} 
#else
const ::CORBA::TypeCode_ptr IIS::_tc_TimedVelocity2D = _0RL_tc_IIS_mTimedVelocity2D;
#endif



static CORBA::PR_structMember _0RL_structmember_IIS_mTimedState[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"id", CORBA::TypeCode::PR_long_tc()},
  {"isStop", CORBA::TypeCode::PR_boolean_tc()}
};

#ifdef _0RL_tc_IIS_mTimedState
#  undef _0RL_tc_IIS_mTimedState
#endif
static CORBA::TypeCode_ptr _0RL_tc_IIS_mTimedState = CORBA::TypeCode::PR_struct_tc("IDL:IIS/TimedState:1.0", "TimedState", _0RL_structmember_IIS_mTimedState, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IIS { 
  const ::CORBA::TypeCode_ptr _tc_TimedState = _0RL_tc_IIS_mTimedState;
} 
#else
const ::CORBA::TypeCode_ptr IIS::_tc_TimedState = _0RL_tc_IIS_mTimedState;
#endif


static void _0RL_RTC_mTimedVelocity_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedVelocity* _p = (RTC::TimedVelocity*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedVelocity_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedVelocity* _p = new RTC::TimedVelocity;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedVelocity_destructor_fn(void* _v)
{
  RTC::TimedVelocity* _p = (RTC::TimedVelocity*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedVelocity& _s)
{
  RTC::TimedVelocity* _p = new RTC::TimedVelocity(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedVelocity,
               _0RL_RTC_mTimedVelocity_marshal_fn,
               _0RL_RTC_mTimedVelocity_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedVelocity* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedVelocity,
               _0RL_RTC_mTimedVelocity_marshal_fn,
               _0RL_RTC_mTimedVelocity_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedVelocity*& _sp)
{
  return _a >>= (const RTC::TimedVelocity*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedVelocity*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedVelocity,
                    _0RL_RTC_mTimedVelocity_unmarshal_fn,
                    _0RL_RTC_mTimedVelocity_marshal_fn,
                    _0RL_RTC_mTimedVelocity_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedVelocity*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedOdometry_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedOdometry* _p = (RTC::TimedOdometry*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedOdometry_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedOdometry* _p = new RTC::TimedOdometry;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedOdometry_destructor_fn(void* _v)
{
  RTC::TimedOdometry* _p = (RTC::TimedOdometry*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedOdometry& _s)
{
  RTC::TimedOdometry* _p = new RTC::TimedOdometry(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedOdometry,
               _0RL_RTC_mTimedOdometry_marshal_fn,
               _0RL_RTC_mTimedOdometry_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedOdometry* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedOdometry,
               _0RL_RTC_mTimedOdometry_marshal_fn,
               _0RL_RTC_mTimedOdometry_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedOdometry*& _sp)
{
  return _a >>= (const RTC::TimedOdometry*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedOdometry*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedOdometry,
                    _0RL_RTC_mTimedOdometry_unmarshal_fn,
                    _0RL_RTC_mTimedOdometry_marshal_fn,
                    _0RL_RTC_mTimedOdometry_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedOdometry*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedScan_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedScan* _p = (RTC::TimedScan*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedScan_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedScan* _p = new RTC::TimedScan;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedScan_destructor_fn(void* _v)
{
  RTC::TimedScan* _p = (RTC::TimedScan*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedScan& _s)
{
  RTC::TimedScan* _p = new RTC::TimedScan(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedScan,
               _0RL_RTC_mTimedScan_marshal_fn,
               _0RL_RTC_mTimedScan_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedScan* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedScan,
               _0RL_RTC_mTimedScan_marshal_fn,
               _0RL_RTC_mTimedScan_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedScan*& _sp)
{
  return _a >>= (const RTC::TimedScan*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedScan*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedScan,
                    _0RL_RTC_mTimedScan_unmarshal_fn,
                    _0RL_RTC_mTimedScan_marshal_fn,
                    _0RL_RTC_mTimedScan_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedScan*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPath_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Path* _p = (RTC::Path*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPath_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Path* _p = new RTC::Path;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPath_destructor_fn(void* _v)
{
  RTC::Path* _p = (RTC::Path*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Path& _s)
{
  RTC::Path* _p = new RTC::Path(_s);
  _a.PR_insert(_0RL_tc_RTC_mPath,
               _0RL_RTC_mPath_marshal_fn,
               _0RL_RTC_mPath_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Path* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPath,
               _0RL_RTC_mPath_marshal_fn,
               _0RL_RTC_mPath_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Path*& _sp)
{
  return _a >>= (const RTC::Path*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Path*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPath,
                    _0RL_RTC_mPath_unmarshal_fn,
                    _0RL_RTC_mPath_marshal_fn,
                    _0RL_RTC_mPath_destructor_fn,
                    _v)) {
    _sp = (const RTC::Path*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPathSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PathSeq* _p = (RTC::PathSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPathSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PathSeq* _p = new RTC::PathSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPathSeq_destructor_fn(void* _v)
{
  RTC::PathSeq* _p = (RTC::PathSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PathSeq& _s)
{
  RTC::PathSeq* _p = new RTC::PathSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mPathSeq,
               _0RL_RTC_mPathSeq_marshal_fn,
               _0RL_RTC_mPathSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PathSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPathSeq,
               _0RL_RTC_mPathSeq_marshal_fn,
               _0RL_RTC_mPathSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PathSeq*& _sp)
{
  return _a >>= (const RTC::PathSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PathSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPathSeq,
                    _0RL_RTC_mPathSeq_unmarshal_fn,
                    _0RL_RTC_mPathSeq_marshal_fn,
                    _0RL_RTC_mPathSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::PathSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedObstacle_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedObstacle* _p = (RTC::TimedObstacle*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedObstacle_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedObstacle* _p = new RTC::TimedObstacle;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedObstacle_destructor_fn(void* _v)
{
  RTC::TimedObstacle* _p = (RTC::TimedObstacle*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedObstacle& _s)
{
  RTC::TimedObstacle* _p = new RTC::TimedObstacle(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedObstacle,
               _0RL_RTC_mTimedObstacle_marshal_fn,
               _0RL_RTC_mTimedObstacle_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedObstacle* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedObstacle,
               _0RL_RTC_mTimedObstacle_marshal_fn,
               _0RL_RTC_mTimedObstacle_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedObstacle*& _sp)
{
  return _a >>= (const RTC::TimedObstacle*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedObstacle*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedObstacle,
                    _0RL_RTC_mTimedObstacle_unmarshal_fn,
                    _0RL_RTC_mTimedObstacle_marshal_fn,
                    _0RL_RTC_mTimedObstacle_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedObstacle*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedMovingObstacle_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedMovingObstacle* _p = (RTC::TimedMovingObstacle*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedMovingObstacle_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedMovingObstacle* _p = new RTC::TimedMovingObstacle;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedMovingObstacle_destructor_fn(void* _v)
{
  RTC::TimedMovingObstacle* _p = (RTC::TimedMovingObstacle*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedMovingObstacle& _s)
{
  RTC::TimedMovingObstacle* _p = new RTC::TimedMovingObstacle(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedMovingObstacle,
               _0RL_RTC_mTimedMovingObstacle_marshal_fn,
               _0RL_RTC_mTimedMovingObstacle_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedMovingObstacle* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedMovingObstacle,
               _0RL_RTC_mTimedMovingObstacle_marshal_fn,
               _0RL_RTC_mTimedMovingObstacle_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedMovingObstacle*& _sp)
{
  return _a >>= (const RTC::TimedMovingObstacle*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedMovingObstacle*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedMovingObstacle,
                    _0RL_RTC_mTimedMovingObstacle_unmarshal_fn,
                    _0RL_RTC_mTimedMovingObstacle_marshal_fn,
                    _0RL_RTC_mTimedMovingObstacle_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedMovingObstacle*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedObstacles_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedObstacles* _p = (RTC::TimedObstacles*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedObstacles_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedObstacles* _p = new RTC::TimedObstacles;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedObstacles_destructor_fn(void* _v)
{
  RTC::TimedObstacles* _p = (RTC::TimedObstacles*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedObstacles& _s)
{
  RTC::TimedObstacles* _p = new RTC::TimedObstacles(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedObstacles,
               _0RL_RTC_mTimedObstacles_marshal_fn,
               _0RL_RTC_mTimedObstacles_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedObstacles* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedObstacles,
               _0RL_RTC_mTimedObstacles_marshal_fn,
               _0RL_RTC_mTimedObstacles_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedObstacles*& _sp)
{
  return _a >>= (const RTC::TimedObstacles*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedObstacles*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedObstacles,
                    _0RL_RTC_mTimedObstacles_unmarshal_fn,
                    _0RL_RTC_mTimedObstacles_marshal_fn,
                    _0RL_RTC_mTimedObstacles_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedObstacles*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedMovingObstacles_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedMovingObstacles* _p = (RTC::TimedMovingObstacles*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedMovingObstacles_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedMovingObstacles* _p = new RTC::TimedMovingObstacles;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedMovingObstacles_destructor_fn(void* _v)
{
  RTC::TimedMovingObstacles* _p = (RTC::TimedMovingObstacles*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedMovingObstacles& _s)
{
  RTC::TimedMovingObstacles* _p = new RTC::TimedMovingObstacles(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedMovingObstacles,
               _0RL_RTC_mTimedMovingObstacles_marshal_fn,
               _0RL_RTC_mTimedMovingObstacles_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedMovingObstacles* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedMovingObstacles,
               _0RL_RTC_mTimedMovingObstacles_marshal_fn,
               _0RL_RTC_mTimedMovingObstacles_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedMovingObstacles*& _sp)
{
  return _a >>= (const RTC::TimedMovingObstacles*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedMovingObstacles*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedMovingObstacles,
                    _0RL_RTC_mTimedMovingObstacles_unmarshal_fn,
                    _0RL_RTC_mTimedMovingObstacles_marshal_fn,
                    _0RL_RTC_mTimedMovingObstacles_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedMovingObstacles*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedParticle_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedParticle* _p = (RTC::TimedParticle*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedParticle_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedParticle* _p = new RTC::TimedParticle;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedParticle_destructor_fn(void* _v)
{
  RTC::TimedParticle* _p = (RTC::TimedParticle*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedParticle& _s)
{
  RTC::TimedParticle* _p = new RTC::TimedParticle(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedParticle,
               _0RL_RTC_mTimedParticle_marshal_fn,
               _0RL_RTC_mTimedParticle_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedParticle* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedParticle,
               _0RL_RTC_mTimedParticle_marshal_fn,
               _0RL_RTC_mTimedParticle_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedParticle*& _sp)
{
  return _a >>= (const RTC::TimedParticle*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedParticle*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedParticle,
                    _0RL_RTC_mTimedParticle_unmarshal_fn,
                    _0RL_RTC_mTimedParticle_marshal_fn,
                    _0RL_RTC_mTimedParticle_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedParticle*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedParticles_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedParticles* _p = (RTC::TimedParticles*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedParticles_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedParticles* _p = new RTC::TimedParticles;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedParticles_destructor_fn(void* _v)
{
  RTC::TimedParticles* _p = (RTC::TimedParticles*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedParticles& _s)
{
  RTC::TimedParticles* _p = new RTC::TimedParticles(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedParticles,
               _0RL_RTC_mTimedParticles_marshal_fn,
               _0RL_RTC_mTimedParticles_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedParticles* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedParticles,
               _0RL_RTC_mTimedParticles_marshal_fn,
               _0RL_RTC_mTimedParticles_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedParticles*& _sp)
{
  return _a >>= (const RTC::TimedParticles*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedParticles*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedParticles,
                    _0RL_RTC_mTimedParticles_unmarshal_fn,
                    _0RL_RTC_mTimedParticles_marshal_fn,
                    _0RL_RTC_mTimedParticles_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedParticles*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedFormationMember_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedFormationMember* _p = (RTC::TimedFormationMember*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedFormationMember_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedFormationMember* _p = new RTC::TimedFormationMember;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedFormationMember_destructor_fn(void* _v)
{
  RTC::TimedFormationMember* _p = (RTC::TimedFormationMember*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedFormationMember& _s)
{
  RTC::TimedFormationMember* _p = new RTC::TimedFormationMember(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedFormationMember,
               _0RL_RTC_mTimedFormationMember_marshal_fn,
               _0RL_RTC_mTimedFormationMember_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedFormationMember* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedFormationMember,
               _0RL_RTC_mTimedFormationMember_marshal_fn,
               _0RL_RTC_mTimedFormationMember_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedFormationMember*& _sp)
{
  return _a >>= (const RTC::TimedFormationMember*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedFormationMember*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedFormationMember,
                    _0RL_RTC_mTimedFormationMember_unmarshal_fn,
                    _0RL_RTC_mTimedFormationMember_marshal_fn,
                    _0RL_RTC_mTimedFormationMember_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedFormationMember*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedFormationReference_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedFormationReference* _p = (RTC::TimedFormationReference*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedFormationReference_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedFormationReference* _p = new RTC::TimedFormationReference;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedFormationReference_destructor_fn(void* _v)
{
  RTC::TimedFormationReference* _p = (RTC::TimedFormationReference*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedFormationReference& _s)
{
  RTC::TimedFormationReference* _p = new RTC::TimedFormationReference(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedFormationReference,
               _0RL_RTC_mTimedFormationReference_marshal_fn,
               _0RL_RTC_mTimedFormationReference_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedFormationReference* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedFormationReference,
               _0RL_RTC_mTimedFormationReference_marshal_fn,
               _0RL_RTC_mTimedFormationReference_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedFormationReference*& _sp)
{
  return _a >>= (const RTC::TimedFormationReference*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedFormationReference*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedFormationReference,
                    _0RL_RTC_mTimedFormationReference_unmarshal_fn,
                    _0RL_RTC_mTimedFormationReference_marshal_fn,
                    _0RL_RTC_mTimedFormationReference_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedFormationReference*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedRobotData_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedRobotData* _p = (RTC::TimedRobotData*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedRobotData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedRobotData* _p = new RTC::TimedRobotData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedRobotData_destructor_fn(void* _v)
{
  RTC::TimedRobotData* _p = (RTC::TimedRobotData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedRobotData& _s)
{
  RTC::TimedRobotData* _p = new RTC::TimedRobotData(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedRobotData,
               _0RL_RTC_mTimedRobotData_marshal_fn,
               _0RL_RTC_mTimedRobotData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedRobotData* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedRobotData,
               _0RL_RTC_mTimedRobotData_marshal_fn,
               _0RL_RTC_mTimedRobotData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedRobotData*& _sp)
{
  return _a >>= (const RTC::TimedRobotData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedRobotData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedRobotData,
                    _0RL_RTC_mTimedRobotData_unmarshal_fn,
                    _0RL_RTC_mTimedRobotData_marshal_fn,
                    _0RL_RTC_mTimedRobotData_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedRobotData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFormationReferenceSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::FormationReferenceSeq* _p = (RTC::FormationReferenceSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFormationReferenceSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::FormationReferenceSeq* _p = new RTC::FormationReferenceSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFormationReferenceSeq_destructor_fn(void* _v)
{
  RTC::FormationReferenceSeq* _p = (RTC::FormationReferenceSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::FormationReferenceSeq& _s)
{
  RTC::FormationReferenceSeq* _p = new RTC::FormationReferenceSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mFormationReferenceSeq,
               _0RL_RTC_mFormationReferenceSeq_marshal_fn,
               _0RL_RTC_mFormationReferenceSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::FormationReferenceSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFormationReferenceSeq,
               _0RL_RTC_mFormationReferenceSeq_marshal_fn,
               _0RL_RTC_mFormationReferenceSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FormationReferenceSeq*& _sp)
{
  return _a >>= (const RTC::FormationReferenceSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FormationReferenceSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFormationReferenceSeq,
                    _0RL_RTC_mFormationReferenceSeq_unmarshal_fn,
                    _0RL_RTC_mFormationReferenceSeq_marshal_fn,
                    _0RL_RTC_mFormationReferenceSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::FormationReferenceSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mFormationMemberSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::FormationMemberSeq* _p = (RTC::FormationMemberSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mFormationMemberSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::FormationMemberSeq* _p = new RTC::FormationMemberSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mFormationMemberSeq_destructor_fn(void* _v)
{
  RTC::FormationMemberSeq* _p = (RTC::FormationMemberSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::FormationMemberSeq& _s)
{
  RTC::FormationMemberSeq* _p = new RTC::FormationMemberSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mFormationMemberSeq,
               _0RL_RTC_mFormationMemberSeq_marshal_fn,
               _0RL_RTC_mFormationMemberSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::FormationMemberSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mFormationMemberSeq,
               _0RL_RTC_mFormationMemberSeq_marshal_fn,
               _0RL_RTC_mFormationMemberSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::FormationMemberSeq*& _sp)
{
  return _a >>= (const RTC::FormationMemberSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::FormationMemberSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mFormationMemberSeq,
                    _0RL_RTC_mFormationMemberSeq_unmarshal_fn,
                    _0RL_RTC_mFormationMemberSeq_marshal_fn,
                    _0RL_RTC_mFormationMemberSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::FormationMemberSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRobotDataSeq_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RobotDataSeq* _p = (RTC::RobotDataSeq*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRobotDataSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RobotDataSeq* _p = new RTC::RobotDataSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRobotDataSeq_destructor_fn(void* _v)
{
  RTC::RobotDataSeq* _p = (RTC::RobotDataSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::RobotDataSeq& _s)
{
  RTC::RobotDataSeq* _p = new RTC::RobotDataSeq(_s);
  _a.PR_insert(_0RL_tc_RTC_mRobotDataSeq,
               _0RL_RTC_mRobotDataSeq_marshal_fn,
               _0RL_RTC_mRobotDataSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::RobotDataSeq* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRobotDataSeq,
               _0RL_RTC_mRobotDataSeq_marshal_fn,
               _0RL_RTC_mRobotDataSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RobotDataSeq*& _sp)
{
  return _a >>= (const RTC::RobotDataSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RobotDataSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRobotDataSeq,
                    _0RL_RTC_mRobotDataSeq_unmarshal_fn,
                    _0RL_RTC_mRobotDataSeq_marshal_fn,
                    _0RL_RTC_mRobotDataSeq_destructor_fn,
                    _v)) {
    _sp = (const RTC::RobotDataSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGga__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Gga_message* _p = (RTC::Gga_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGga__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Gga_message* _p = new RTC::Gga_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGga__message_destructor_fn(void* _v)
{
  RTC::Gga_message* _p = (RTC::Gga_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Gga_message& _s)
{
  RTC::Gga_message* _p = new RTC::Gga_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mGga__message,
               _0RL_RTC_mGga__message_marshal_fn,
               _0RL_RTC_mGga__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Gga_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGga__message,
               _0RL_RTC_mGga__message_marshal_fn,
               _0RL_RTC_mGga__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Gga_message*& _sp)
{
  return _a >>= (const RTC::Gga_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Gga_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGga__message,
                    _0RL_RTC_mGga__message_unmarshal_fn,
                    _0RL_RTC_mGga__message_marshal_fn,
                    _0RL_RTC_mGga__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Gga_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGll__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Gll_message* _p = (RTC::Gll_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGll__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Gll_message* _p = new RTC::Gll_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGll__message_destructor_fn(void* _v)
{
  RTC::Gll_message* _p = (RTC::Gll_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Gll_message& _s)
{
  RTC::Gll_message* _p = new RTC::Gll_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mGll__message,
               _0RL_RTC_mGll__message_marshal_fn,
               _0RL_RTC_mGll__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Gll_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGll__message,
               _0RL_RTC_mGll__message_marshal_fn,
               _0RL_RTC_mGll__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Gll_message*& _sp)
{
  return _a >>= (const RTC::Gll_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Gll_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGll__message,
                    _0RL_RTC_mGll__message_unmarshal_fn,
                    _0RL_RTC_mGll__message_marshal_fn,
                    _0RL_RTC_mGll__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Gll_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGns__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Gns_message* _p = (RTC::Gns_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGns__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Gns_message* _p = new RTC::Gns_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGns__message_destructor_fn(void* _v)
{
  RTC::Gns_message* _p = (RTC::Gns_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Gns_message& _s)
{
  RTC::Gns_message* _p = new RTC::Gns_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mGns__message,
               _0RL_RTC_mGns__message_marshal_fn,
               _0RL_RTC_mGns__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Gns_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGns__message,
               _0RL_RTC_mGns__message_marshal_fn,
               _0RL_RTC_mGns__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Gns_message*& _sp)
{
  return _a >>= (const RTC::Gns_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Gns_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGns__message,
                    _0RL_RTC_mGns__message_unmarshal_fn,
                    _0RL_RTC_mGns__message_marshal_fn,
                    _0RL_RTC_mGns__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Gns_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGrs__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Grs_message* _p = (RTC::Grs_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGrs__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Grs_message* _p = new RTC::Grs_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGrs__message_destructor_fn(void* _v)
{
  RTC::Grs_message* _p = (RTC::Grs_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Grs_message& _s)
{
  RTC::Grs_message* _p = new RTC::Grs_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mGrs__message,
               _0RL_RTC_mGrs__message_marshal_fn,
               _0RL_RTC_mGrs__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Grs_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGrs__message,
               _0RL_RTC_mGrs__message_marshal_fn,
               _0RL_RTC_mGrs__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Grs_message*& _sp)
{
  return _a >>= (const RTC::Grs_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Grs_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGrs__message,
                    _0RL_RTC_mGrs__message_unmarshal_fn,
                    _0RL_RTC_mGrs__message_marshal_fn,
                    _0RL_RTC_mGrs__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Grs_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGsa__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Gsa_message* _p = (RTC::Gsa_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGsa__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Gsa_message* _p = new RTC::Gsa_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGsa__message_destructor_fn(void* _v)
{
  RTC::Gsa_message* _p = (RTC::Gsa_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Gsa_message& _s)
{
  RTC::Gsa_message* _p = new RTC::Gsa_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mGsa__message,
               _0RL_RTC_mGsa__message_marshal_fn,
               _0RL_RTC_mGsa__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Gsa_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGsa__message,
               _0RL_RTC_mGsa__message_marshal_fn,
               _0RL_RTC_mGsa__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Gsa_message*& _sp)
{
  return _a >>= (const RTC::Gsa_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Gsa_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGsa__message,
                    _0RL_RTC_mGsa__message_unmarshal_fn,
                    _0RL_RTC_mGsa__message_marshal_fn,
                    _0RL_RTC_mGsa__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Gsa_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGst__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Gst_message* _p = (RTC::Gst_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGst__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Gst_message* _p = new RTC::Gst_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGst__message_destructor_fn(void* _v)
{
  RTC::Gst_message* _p = (RTC::Gst_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Gst_message& _s)
{
  RTC::Gst_message* _p = new RTC::Gst_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mGst__message,
               _0RL_RTC_mGst__message_marshal_fn,
               _0RL_RTC_mGst__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Gst_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGst__message,
               _0RL_RTC_mGst__message_marshal_fn,
               _0RL_RTC_mGst__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Gst_message*& _sp)
{
  return _a >>= (const RTC::Gst_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Gst_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGst__message,
                    _0RL_RTC_mGst__message_unmarshal_fn,
                    _0RL_RTC_mGst__message_marshal_fn,
                    _0RL_RTC_mGst__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Gst_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGsv__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Gsv_message* _p = (RTC::Gsv_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGsv__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Gsv_message* _p = new RTC::Gsv_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGsv__message_destructor_fn(void* _v)
{
  RTC::Gsv_message* _p = (RTC::Gsv_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Gsv_message& _s)
{
  RTC::Gsv_message* _p = new RTC::Gsv_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mGsv__message,
               _0RL_RTC_mGsv__message_marshal_fn,
               _0RL_RTC_mGsv__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Gsv_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGsv__message,
               _0RL_RTC_mGsv__message_marshal_fn,
               _0RL_RTC_mGsv__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Gsv_message*& _sp)
{
  return _a >>= (const RTC::Gsv_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Gsv_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGsv__message,
                    _0RL_RTC_mGsv__message_unmarshal_fn,
                    _0RL_RTC_mGsv__message_marshal_fn,
                    _0RL_RTC_mGsv__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Gsv_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mHdt__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Hdt_message* _p = (RTC::Hdt_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mHdt__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Hdt_message* _p = new RTC::Hdt_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mHdt__message_destructor_fn(void* _v)
{
  RTC::Hdt_message* _p = (RTC::Hdt_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Hdt_message& _s)
{
  RTC::Hdt_message* _p = new RTC::Hdt_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mHdt__message,
               _0RL_RTC_mHdt__message_marshal_fn,
               _0RL_RTC_mHdt__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Hdt_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mHdt__message,
               _0RL_RTC_mHdt__message_marshal_fn,
               _0RL_RTC_mHdt__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Hdt_message*& _sp)
{
  return _a >>= (const RTC::Hdt_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Hdt_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mHdt__message,
                    _0RL_RTC_mHdt__message_unmarshal_fn,
                    _0RL_RTC_mHdt__message_marshal_fn,
                    _0RL_RTC_mHdt__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Hdt_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRmc__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Rmc_message* _p = (RTC::Rmc_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRmc__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Rmc_message* _p = new RTC::Rmc_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRmc__message_destructor_fn(void* _v)
{
  RTC::Rmc_message* _p = (RTC::Rmc_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Rmc_message& _s)
{
  RTC::Rmc_message* _p = new RTC::Rmc_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mRmc__message,
               _0RL_RTC_mRmc__message_marshal_fn,
               _0RL_RTC_mRmc__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Rmc_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRmc__message,
               _0RL_RTC_mRmc__message_marshal_fn,
               _0RL_RTC_mRmc__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Rmc_message*& _sp)
{
  return _a >>= (const RTC::Rmc_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Rmc_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRmc__message,
                    _0RL_RTC_mRmc__message_unmarshal_fn,
                    _0RL_RTC_mRmc__message_marshal_fn,
                    _0RL_RTC_mRmc__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Rmc_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mVtg__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Vtg_message* _p = (RTC::Vtg_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mVtg__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Vtg_message* _p = new RTC::Vtg_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mVtg__message_destructor_fn(void* _v)
{
  RTC::Vtg_message* _p = (RTC::Vtg_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Vtg_message& _s)
{
  RTC::Vtg_message* _p = new RTC::Vtg_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mVtg__message,
               _0RL_RTC_mVtg__message_marshal_fn,
               _0RL_RTC_mVtg__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Vtg_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mVtg__message,
               _0RL_RTC_mVtg__message_marshal_fn,
               _0RL_RTC_mVtg__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Vtg_message*& _sp)
{
  return _a >>= (const RTC::Vtg_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Vtg_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mVtg__message,
                    _0RL_RTC_mVtg__message_unmarshal_fn,
                    _0RL_RTC_mVtg__message_marshal_fn,
                    _0RL_RTC_mVtg__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Vtg_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mZda__message_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Zda_message* _p = (RTC::Zda_message*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mZda__message_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Zda_message* _p = new RTC::Zda_message;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mZda__message_destructor_fn(void* _v)
{
  RTC::Zda_message* _p = (RTC::Zda_message*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Zda_message& _s)
{
  RTC::Zda_message* _p = new RTC::Zda_message(_s);
  _a.PR_insert(_0RL_tc_RTC_mZda__message,
               _0RL_RTC_mZda__message_marshal_fn,
               _0RL_RTC_mZda__message_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Zda_message* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mZda__message,
               _0RL_RTC_mZda__message_marshal_fn,
               _0RL_RTC_mZda__message_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Zda_message*& _sp)
{
  return _a >>= (const RTC::Zda_message*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Zda_message*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mZda__message,
                    _0RL_RTC_mZda__message_unmarshal_fn,
                    _0RL_RTC_mZda__message_marshal_fn,
                    _0RL_RTC_mZda__message_destructor_fn,
                    _v)) {
    _sp = (const RTC::Zda_message*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedLegacyData_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedLegacyData* _p = (RTC::TimedLegacyData*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedLegacyData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedLegacyData* _p = new RTC::TimedLegacyData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedLegacyData_destructor_fn(void* _v)
{
  RTC::TimedLegacyData* _p = (RTC::TimedLegacyData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedLegacyData& _s)
{
  RTC::TimedLegacyData* _p = new RTC::TimedLegacyData(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedLegacyData,
               _0RL_RTC_mTimedLegacyData_marshal_fn,
               _0RL_RTC_mTimedLegacyData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedLegacyData* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedLegacyData,
               _0RL_RTC_mTimedLegacyData_marshal_fn,
               _0RL_RTC_mTimedLegacyData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedLegacyData*& _sp)
{
  return _a >>= (const RTC::TimedLegacyData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedLegacyData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedLegacyData,
                    _0RL_RTC_mTimedLegacyData_unmarshal_fn,
                    _0RL_RTC_mTimedLegacyData_marshal_fn,
                    _0RL_RTC_mTimedLegacyData_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedLegacyData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedJgd2000Position_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedJgd2000Position* _p = (RTC::TimedJgd2000Position*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedJgd2000Position_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedJgd2000Position* _p = new RTC::TimedJgd2000Position;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedJgd2000Position_destructor_fn(void* _v)
{
  RTC::TimedJgd2000Position* _p = (RTC::TimedJgd2000Position*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedJgd2000Position& _s)
{
  RTC::TimedJgd2000Position* _p = new RTC::TimedJgd2000Position(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedJgd2000Position,
               _0RL_RTC_mTimedJgd2000Position_marshal_fn,
               _0RL_RTC_mTimedJgd2000Position_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedJgd2000Position* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedJgd2000Position,
               _0RL_RTC_mTimedJgd2000Position_marshal_fn,
               _0RL_RTC_mTimedJgd2000Position_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedJgd2000Position*& _sp)
{
  return _a >>= (const RTC::TimedJgd2000Position*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedJgd2000Position*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedJgd2000Position,
                    _0RL_RTC_mTimedJgd2000Position_unmarshal_fn,
                    _0RL_RTC_mTimedJgd2000Position_marshal_fn,
                    _0RL_RTC_mTimedJgd2000Position_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedJgd2000Position*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedGpsData_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedGpsData* _p = (RTC::TimedGpsData*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedGpsData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedGpsData* _p = new RTC::TimedGpsData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedGpsData_destructor_fn(void* _v)
{
  RTC::TimedGpsData* _p = (RTC::TimedGpsData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedGpsData& _s)
{
  RTC::TimedGpsData* _p = new RTC::TimedGpsData(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedGpsData,
               _0RL_RTC_mTimedGpsData_marshal_fn,
               _0RL_RTC_mTimedGpsData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedGpsData* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedGpsData,
               _0RL_RTC_mTimedGpsData_marshal_fn,
               _0RL_RTC_mTimedGpsData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedGpsData*& _sp)
{
  return _a >>= (const RTC::TimedGpsData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedGpsData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedGpsData,
                    _0RL_RTC_mTimedGpsData_unmarshal_fn,
                    _0RL_RTC_mTimedGpsData_marshal_fn,
                    _0RL_RTC_mTimedGpsData_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedGpsData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimed19Position_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Timed19Position* _p = (RTC::Timed19Position*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimed19Position_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Timed19Position* _p = new RTC::Timed19Position;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimed19Position_destructor_fn(void* _v)
{
  RTC::Timed19Position* _p = (RTC::Timed19Position*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Timed19Position& _s)
{
  RTC::Timed19Position* _p = new RTC::Timed19Position(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimed19Position,
               _0RL_RTC_mTimed19Position_marshal_fn,
               _0RL_RTC_mTimed19Position_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Timed19Position* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimed19Position,
               _0RL_RTC_mTimed19Position_marshal_fn,
               _0RL_RTC_mTimed19Position_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Timed19Position*& _sp)
{
  return _a >>= (const RTC::Timed19Position*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Timed19Position*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimed19Position,
                    _0RL_RTC_mTimed19Position_unmarshal_fn,
                    _0RL_RTC_mTimed19Position_marshal_fn,
                    _0RL_RTC_mTimed19Position_destructor_fn,
                    _v)) {
    _sp = (const RTC::Timed19Position*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedRobotPosition_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedRobotPosition* _p = (RTC::TimedRobotPosition*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedRobotPosition_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedRobotPosition* _p = new RTC::TimedRobotPosition;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedRobotPosition_destructor_fn(void* _v)
{
  RTC::TimedRobotPosition* _p = (RTC::TimedRobotPosition*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedRobotPosition& _s)
{
  RTC::TimedRobotPosition* _p = new RTC::TimedRobotPosition(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedRobotPosition,
               _0RL_RTC_mTimedRobotPosition_marshal_fn,
               _0RL_RTC_mTimedRobotPosition_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedRobotPosition* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedRobotPosition,
               _0RL_RTC_mTimedRobotPosition_marshal_fn,
               _0RL_RTC_mTimedRobotPosition_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedRobotPosition*& _sp)
{
  return _a >>= (const RTC::TimedRobotPosition*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedRobotPosition*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedRobotPosition,
                    _0RL_RTC_mTimedRobotPosition_unmarshal_fn,
                    _0RL_RTC_mTimedRobotPosition_marshal_fn,
                    _0RL_RTC_mTimedRobotPosition_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedRobotPosition*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedMapData_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedMapData* _p = (RTC::TimedMapData*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedMapData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedMapData* _p = new RTC::TimedMapData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedMapData_destructor_fn(void* _v)
{
  RTC::TimedMapData* _p = (RTC::TimedMapData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedMapData& _s)
{
  RTC::TimedMapData* _p = new RTC::TimedMapData(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedMapData,
               _0RL_RTC_mTimedMapData_marshal_fn,
               _0RL_RTC_mTimedMapData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedMapData* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedMapData,
               _0RL_RTC_mTimedMapData_marshal_fn,
               _0RL_RTC_mTimedMapData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedMapData*& _sp)
{
  return _a >>= (const RTC::TimedMapData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedMapData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedMapData,
                    _0RL_RTC_mTimedMapData_unmarshal_fn,
                    _0RL_RTC_mTimedMapData_marshal_fn,
                    _0RL_RTC_mTimedMapData_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedMapData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mArc_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Arc* _p = (RTC::Arc*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mArc_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Arc* _p = new RTC::Arc;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mArc_destructor_fn(void* _v)
{
  RTC::Arc* _p = (RTC::Arc*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Arc& _s)
{
  RTC::Arc* _p = new RTC::Arc(_s);
  _a.PR_insert(_0RL_tc_RTC_mArc,
               _0RL_RTC_mArc_marshal_fn,
               _0RL_RTC_mArc_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Arc* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mArc,
               _0RL_RTC_mArc_marshal_fn,
               _0RL_RTC_mArc_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Arc*& _sp)
{
  return _a >>= (const RTC::Arc*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Arc*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mArc,
                    _0RL_RTC_mArc_unmarshal_fn,
                    _0RL_RTC_mArc_marshal_fn,
                    _0RL_RTC_mArc_destructor_fn,
                    _v)) {
    _sp = (const RTC::Arc*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mNode_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Node* _p = (RTC::Node*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mNode_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Node* _p = new RTC::Node;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mNode_destructor_fn(void* _v)
{
  RTC::Node* _p = (RTC::Node*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Node& _s)
{
  RTC::Node* _p = new RTC::Node(_s);
  _a.PR_insert(_0RL_tc_RTC_mNode,
               _0RL_RTC_mNode_marshal_fn,
               _0RL_RTC_mNode_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Node* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mNode,
               _0RL_RTC_mNode_marshal_fn,
               _0RL_RTC_mNode_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Node*& _sp)
{
  return _a >>= (const RTC::Node*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Node*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mNode,
                    _0RL_RTC_mNode_unmarshal_fn,
                    _0RL_RTC_mNode_marshal_fn,
                    _0RL_RTC_mNode_destructor_fn,
                    _v)) {
    _sp = (const RTC::Node*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedArcNode_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedArcNode* _p = (RTC::TimedArcNode*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedArcNode_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedArcNode* _p = new RTC::TimedArcNode;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedArcNode_destructor_fn(void* _v)
{
  RTC::TimedArcNode* _p = (RTC::TimedArcNode*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedArcNode& _s)
{
  RTC::TimedArcNode* _p = new RTC::TimedArcNode(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedArcNode,
               _0RL_RTC_mTimedArcNode_marshal_fn,
               _0RL_RTC_mTimedArcNode_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedArcNode* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedArcNode,
               _0RL_RTC_mTimedArcNode_marshal_fn,
               _0RL_RTC_mTimedArcNode_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedArcNode*& _sp)
{
  return _a >>= (const RTC::TimedArcNode*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedArcNode*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedArcNode,
                    _0RL_RTC_mTimedArcNode_unmarshal_fn,
                    _0RL_RTC_mTimedArcNode_marshal_fn,
                    _0RL_RTC_mTimedArcNode_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedArcNode*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mLine_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Line* _p = (RTC::Line*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mLine_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Line* _p = new RTC::Line;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mLine_destructor_fn(void* _v)
{
  RTC::Line* _p = (RTC::Line*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Line& _s)
{
  RTC::Line* _p = new RTC::Line(_s);
  _a.PR_insert(_0RL_tc_RTC_mLine,
               _0RL_RTC_mLine_marshal_fn,
               _0RL_RTC_mLine_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Line* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mLine,
               _0RL_RTC_mLine_marshal_fn,
               _0RL_RTC_mLine_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Line*& _sp)
{
  return _a >>= (const RTC::Line*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Line*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mLine,
                    _0RL_RTC_mLine_unmarshal_fn,
                    _0RL_RTC_mLine_marshal_fn,
                    _0RL_RTC_mLine_destructor_fn,
                    _v)) {
    _sp = (const RTC::Line*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mCircle_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Circle* _p = (RTC::Circle*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mCircle_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Circle* _p = new RTC::Circle;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mCircle_destructor_fn(void* _v)
{
  RTC::Circle* _p = (RTC::Circle*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Circle& _s)
{
  RTC::Circle* _p = new RTC::Circle(_s);
  _a.PR_insert(_0RL_tc_RTC_mCircle,
               _0RL_RTC_mCircle_marshal_fn,
               _0RL_RTC_mCircle_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Circle* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mCircle,
               _0RL_RTC_mCircle_marshal_fn,
               _0RL_RTC_mCircle_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Circle*& _sp)
{
  return _a >>= (const RTC::Circle*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Circle*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mCircle,
                    _0RL_RTC_mCircle_unmarshal_fn,
                    _0RL_RTC_mCircle_marshal_fn,
                    _0RL_RTC_mCircle_destructor_fn,
                    _v)) {
    _sp = (const RTC::Circle*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedLandmark_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedLandmark* _p = (RTC::TimedLandmark*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedLandmark_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedLandmark* _p = new RTC::TimedLandmark;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedLandmark_destructor_fn(void* _v)
{
  RTC::TimedLandmark* _p = (RTC::TimedLandmark*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedLandmark& _s)
{
  RTC::TimedLandmark* _p = new RTC::TimedLandmark(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedLandmark,
               _0RL_RTC_mTimedLandmark_marshal_fn,
               _0RL_RTC_mTimedLandmark_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedLandmark* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedLandmark,
               _0RL_RTC_mTimedLandmark_marshal_fn,
               _0RL_RTC_mTimedLandmark_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedLandmark*& _sp)
{
  return _a >>= (const RTC::TimedLandmark*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedLandmark*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedLandmark,
                    _0RL_RTC_mTimedLandmark_unmarshal_fn,
                    _0RL_RTC_mTimedLandmark_marshal_fn,
                    _0RL_RTC_mTimedLandmark_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedLandmark*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedMapOrder_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedMapOrder* _p = (RTC::TimedMapOrder*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedMapOrder_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedMapOrder* _p = new RTC::TimedMapOrder;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedMapOrder_destructor_fn(void* _v)
{
  RTC::TimedMapOrder* _p = (RTC::TimedMapOrder*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedMapOrder& _s)
{
  RTC::TimedMapOrder* _p = new RTC::TimedMapOrder(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedMapOrder,
               _0RL_RTC_mTimedMapOrder_marshal_fn,
               _0RL_RTC_mTimedMapOrder_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedMapOrder* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedMapOrder,
               _0RL_RTC_mTimedMapOrder_marshal_fn,
               _0RL_RTC_mTimedMapOrder_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedMapOrder*& _sp)
{
  return _a >>= (const RTC::TimedMapOrder*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedMapOrder*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedMapOrder,
                    _0RL_RTC_mTimedMapOrder_unmarshal_fn,
                    _0RL_RTC_mTimedMapOrder_marshal_fn,
                    _0RL_RTC_mTimedMapOrder_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedMapOrder*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mRobotPosition_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RobotPosition* _p = (RTC::RobotPosition*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRobotPosition_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RobotPosition* _p = new RTC::RobotPosition;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRobotPosition_destructor_fn(void* _v)
{
  RTC::RobotPosition* _p = (RTC::RobotPosition*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::RobotPosition& _s)
{
  RTC::RobotPosition* _p = new RTC::RobotPosition(_s);
  _a.PR_insert(_0RL_tc_RTC_mRobotPosition,
               _0RL_RTC_mRobotPosition_marshal_fn,
               _0RL_RTC_mRobotPosition_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::RobotPosition* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRobotPosition,
               _0RL_RTC_mRobotPosition_marshal_fn,
               _0RL_RTC_mRobotPosition_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RobotPosition*& _sp)
{
  return _a >>= (const RTC::RobotPosition*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RobotPosition*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRobotPosition,
                    _0RL_RTC_mRobotPosition_unmarshal_fn,
                    _0RL_RTC_mRobotPosition_marshal_fn,
                    _0RL_RTC_mRobotPosition_destructor_fn,
                    _v)) {
    _sp = (const RTC::RobotPosition*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedPath_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedPath* _p = (RTC::TimedPath*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedPath_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedPath* _p = new RTC::TimedPath;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedPath_destructor_fn(void* _v)
{
  RTC::TimedPath* _p = (RTC::TimedPath*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedPath& _s)
{
  RTC::TimedPath* _p = new RTC::TimedPath(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedPath,
               _0RL_RTC_mTimedPath_marshal_fn,
               _0RL_RTC_mTimedPath_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedPath* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedPath,
               _0RL_RTC_mTimedPath_marshal_fn,
               _0RL_RTC_mTimedPath_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedPath*& _sp)
{
  return _a >>= (const RTC::TimedPath*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedPath*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedPath,
                    _0RL_RTC_mTimedPath_unmarshal_fn,
                    _0RL_RTC_mTimedPath_marshal_fn,
                    _0RL_RTC_mTimedPath_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedPath*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedMeshOrder_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedMeshOrder* _p = (RTC::TimedMeshOrder*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedMeshOrder_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedMeshOrder* _p = new RTC::TimedMeshOrder;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedMeshOrder_destructor_fn(void* _v)
{
  RTC::TimedMeshOrder* _p = (RTC::TimedMeshOrder*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedMeshOrder& _s)
{
  RTC::TimedMeshOrder* _p = new RTC::TimedMeshOrder(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedMeshOrder,
               _0RL_RTC_mTimedMeshOrder_marshal_fn,
               _0RL_RTC_mTimedMeshOrder_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedMeshOrder* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedMeshOrder,
               _0RL_RTC_mTimedMeshOrder_marshal_fn,
               _0RL_RTC_mTimedMeshOrder_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedMeshOrder*& _sp)
{
  return _a >>= (const RTC::TimedMeshOrder*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedMeshOrder*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedMeshOrder,
                    _0RL_RTC_mTimedMeshOrder_unmarshal_fn,
                    _0RL_RTC_mTimedMeshOrder_marshal_fn,
                    _0RL_RTC_mTimedMeshOrder_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedMeshOrder*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IIS_mTanakaTest_marshal_fn(cdrStream& _s, void* _v)
{
  IIS::TanakaTest* _p = (IIS::TanakaTest*)_v;
  *_p >>= _s;
}
static void _0RL_IIS_mTanakaTest_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IIS::TanakaTest* _p = new IIS::TanakaTest;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IIS_mTanakaTest_destructor_fn(void* _v)
{
  IIS::TanakaTest* _p = (IIS::TanakaTest*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IIS::TanakaTest& _s)
{
  IIS::TanakaTest* _p = new IIS::TanakaTest(_s);
  _a.PR_insert(_0RL_tc_IIS_mTanakaTest,
               _0RL_IIS_mTanakaTest_marshal_fn,
               _0RL_IIS_mTanakaTest_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IIS::TanakaTest* _sp)
{
  _a.PR_insert(_0RL_tc_IIS_mTanakaTest,
               _0RL_IIS_mTanakaTest_marshal_fn,
               _0RL_IIS_mTanakaTest_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IIS::TanakaTest*& _sp)
{
  return _a >>= (const IIS::TanakaTest*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IIS::TanakaTest*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IIS_mTanakaTest,
                    _0RL_IIS_mTanakaTest_unmarshal_fn,
                    _0RL_IIS_mTanakaTest_marshal_fn,
                    _0RL_IIS_mTanakaTest_destructor_fn,
                    _v)) {
    _sp = (const IIS::TanakaTest*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IIS_mTimedVelocity_marshal_fn(cdrStream& _s, void* _v)
{
  IIS::TimedVelocity* _p = (IIS::TimedVelocity*)_v;
  *_p >>= _s;
}
static void _0RL_IIS_mTimedVelocity_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IIS::TimedVelocity* _p = new IIS::TimedVelocity;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IIS_mTimedVelocity_destructor_fn(void* _v)
{
  IIS::TimedVelocity* _p = (IIS::TimedVelocity*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IIS::TimedVelocity& _s)
{
  IIS::TimedVelocity* _p = new IIS::TimedVelocity(_s);
  _a.PR_insert(_0RL_tc_IIS_mTimedVelocity,
               _0RL_IIS_mTimedVelocity_marshal_fn,
               _0RL_IIS_mTimedVelocity_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IIS::TimedVelocity* _sp)
{
  _a.PR_insert(_0RL_tc_IIS_mTimedVelocity,
               _0RL_IIS_mTimedVelocity_marshal_fn,
               _0RL_IIS_mTimedVelocity_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IIS::TimedVelocity*& _sp)
{
  return _a >>= (const IIS::TimedVelocity*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IIS::TimedVelocity*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IIS_mTimedVelocity,
                    _0RL_IIS_mTimedVelocity_unmarshal_fn,
                    _0RL_IIS_mTimedVelocity_marshal_fn,
                    _0RL_IIS_mTimedVelocity_destructor_fn,
                    _v)) {
    _sp = (const IIS::TimedVelocity*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IIS_mTimedPosition_marshal_fn(cdrStream& _s, void* _v)
{
  IIS::TimedPosition* _p = (IIS::TimedPosition*)_v;
  *_p >>= _s;
}
static void _0RL_IIS_mTimedPosition_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IIS::TimedPosition* _p = new IIS::TimedPosition;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IIS_mTimedPosition_destructor_fn(void* _v)
{
  IIS::TimedPosition* _p = (IIS::TimedPosition*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IIS::TimedPosition& _s)
{
  IIS::TimedPosition* _p = new IIS::TimedPosition(_s);
  _a.PR_insert(_0RL_tc_IIS_mTimedPosition,
               _0RL_IIS_mTimedPosition_marshal_fn,
               _0RL_IIS_mTimedPosition_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IIS::TimedPosition* _sp)
{
  _a.PR_insert(_0RL_tc_IIS_mTimedPosition,
               _0RL_IIS_mTimedPosition_marshal_fn,
               _0RL_IIS_mTimedPosition_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IIS::TimedPosition*& _sp)
{
  return _a >>= (const IIS::TimedPosition*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IIS::TimedPosition*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IIS_mTimedPosition,
                    _0RL_IIS_mTimedPosition_unmarshal_fn,
                    _0RL_IIS_mTimedPosition_marshal_fn,
                    _0RL_IIS_mTimedPosition_destructor_fn,
                    _v)) {
    _sp = (const IIS::TimedPosition*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IIS_mTimedPose2D_marshal_fn(cdrStream& _s, void* _v)
{
  IIS::TimedPose2D* _p = (IIS::TimedPose2D*)_v;
  *_p >>= _s;
}
static void _0RL_IIS_mTimedPose2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IIS::TimedPose2D* _p = new IIS::TimedPose2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IIS_mTimedPose2D_destructor_fn(void* _v)
{
  IIS::TimedPose2D* _p = (IIS::TimedPose2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IIS::TimedPose2D& _s)
{
  IIS::TimedPose2D* _p = new IIS::TimedPose2D(_s);
  _a.PR_insert(_0RL_tc_IIS_mTimedPose2D,
               _0RL_IIS_mTimedPose2D_marshal_fn,
               _0RL_IIS_mTimedPose2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IIS::TimedPose2D* _sp)
{
  _a.PR_insert(_0RL_tc_IIS_mTimedPose2D,
               _0RL_IIS_mTimedPose2D_marshal_fn,
               _0RL_IIS_mTimedPose2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IIS::TimedPose2D*& _sp)
{
  return _a >>= (const IIS::TimedPose2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IIS::TimedPose2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IIS_mTimedPose2D,
                    _0RL_IIS_mTimedPose2D_unmarshal_fn,
                    _0RL_IIS_mTimedPose2D_marshal_fn,
                    _0RL_IIS_mTimedPose2D_destructor_fn,
                    _v)) {
    _sp = (const IIS::TimedPose2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IIS_mTimedPose2DSeq_marshal_fn(cdrStream& _s, void* _v)
{
  IIS::TimedPose2DSeq* _p = (IIS::TimedPose2DSeq*)_v;
  *_p >>= _s;
}
static void _0RL_IIS_mTimedPose2DSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IIS::TimedPose2DSeq* _p = new IIS::TimedPose2DSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IIS_mTimedPose2DSeq_destructor_fn(void* _v)
{
  IIS::TimedPose2DSeq* _p = (IIS::TimedPose2DSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IIS::TimedPose2DSeq& _s)
{
  IIS::TimedPose2DSeq* _p = new IIS::TimedPose2DSeq(_s);
  _a.PR_insert(_0RL_tc_IIS_mTimedPose2DSeq,
               _0RL_IIS_mTimedPose2DSeq_marshal_fn,
               _0RL_IIS_mTimedPose2DSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IIS::TimedPose2DSeq* _sp)
{
  _a.PR_insert(_0RL_tc_IIS_mTimedPose2DSeq,
               _0RL_IIS_mTimedPose2DSeq_marshal_fn,
               _0RL_IIS_mTimedPose2DSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IIS::TimedPose2DSeq*& _sp)
{
  return _a >>= (const IIS::TimedPose2DSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IIS::TimedPose2DSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IIS_mTimedPose2DSeq,
                    _0RL_IIS_mTimedPose2DSeq_unmarshal_fn,
                    _0RL_IIS_mTimedPose2DSeq_marshal_fn,
                    _0RL_IIS_mTimedPose2DSeq_destructor_fn,
                    _v)) {
    _sp = (const IIS::TimedPose2DSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IIS_mTimedPath2DSeq_marshal_fn(cdrStream& _s, void* _v)
{
  IIS::TimedPath2DSeq* _p = (IIS::TimedPath2DSeq*)_v;
  *_p >>= _s;
}
static void _0RL_IIS_mTimedPath2DSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IIS::TimedPath2DSeq* _p = new IIS::TimedPath2DSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IIS_mTimedPath2DSeq_destructor_fn(void* _v)
{
  IIS::TimedPath2DSeq* _p = (IIS::TimedPath2DSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IIS::TimedPath2DSeq& _s)
{
  IIS::TimedPath2DSeq* _p = new IIS::TimedPath2DSeq(_s);
  _a.PR_insert(_0RL_tc_IIS_mTimedPath2DSeq,
               _0RL_IIS_mTimedPath2DSeq_marshal_fn,
               _0RL_IIS_mTimedPath2DSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IIS::TimedPath2DSeq* _sp)
{
  _a.PR_insert(_0RL_tc_IIS_mTimedPath2DSeq,
               _0RL_IIS_mTimedPath2DSeq_marshal_fn,
               _0RL_IIS_mTimedPath2DSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IIS::TimedPath2DSeq*& _sp)
{
  return _a >>= (const IIS::TimedPath2DSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IIS::TimedPath2DSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IIS_mTimedPath2DSeq,
                    _0RL_IIS_mTimedPath2DSeq_unmarshal_fn,
                    _0RL_IIS_mTimedPath2DSeq_marshal_fn,
                    _0RL_IIS_mTimedPath2DSeq_destructor_fn,
                    _v)) {
    _sp = (const IIS::TimedPath2DSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IIS_mTimedVelocity2D_marshal_fn(cdrStream& _s, void* _v)
{
  IIS::TimedVelocity2D* _p = (IIS::TimedVelocity2D*)_v;
  *_p >>= _s;
}
static void _0RL_IIS_mTimedVelocity2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IIS::TimedVelocity2D* _p = new IIS::TimedVelocity2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IIS_mTimedVelocity2D_destructor_fn(void* _v)
{
  IIS::TimedVelocity2D* _p = (IIS::TimedVelocity2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IIS::TimedVelocity2D& _s)
{
  IIS::TimedVelocity2D* _p = new IIS::TimedVelocity2D(_s);
  _a.PR_insert(_0RL_tc_IIS_mTimedVelocity2D,
               _0RL_IIS_mTimedVelocity2D_marshal_fn,
               _0RL_IIS_mTimedVelocity2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IIS::TimedVelocity2D* _sp)
{
  _a.PR_insert(_0RL_tc_IIS_mTimedVelocity2D,
               _0RL_IIS_mTimedVelocity2D_marshal_fn,
               _0RL_IIS_mTimedVelocity2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IIS::TimedVelocity2D*& _sp)
{
  return _a >>= (const IIS::TimedVelocity2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IIS::TimedVelocity2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IIS_mTimedVelocity2D,
                    _0RL_IIS_mTimedVelocity2D_unmarshal_fn,
                    _0RL_IIS_mTimedVelocity2D_marshal_fn,
                    _0RL_IIS_mTimedVelocity2D_destructor_fn,
                    _v)) {
    _sp = (const IIS::TimedVelocity2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IIS_mTimedState_marshal_fn(cdrStream& _s, void* _v)
{
  IIS::TimedState* _p = (IIS::TimedState*)_v;
  *_p >>= _s;
}
static void _0RL_IIS_mTimedState_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IIS::TimedState* _p = new IIS::TimedState;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IIS_mTimedState_destructor_fn(void* _v)
{
  IIS::TimedState* _p = (IIS::TimedState*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IIS::TimedState& _s)
{
  IIS::TimedState* _p = new IIS::TimedState(_s);
  _a.PR_insert(_0RL_tc_IIS_mTimedState,
               _0RL_IIS_mTimedState_marshal_fn,
               _0RL_IIS_mTimedState_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IIS::TimedState* _sp)
{
  _a.PR_insert(_0RL_tc_IIS_mTimedState,
               _0RL_IIS_mTimedState_marshal_fn,
               _0RL_IIS_mTimedState_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IIS::TimedState*& _sp)
{
  return _a >>= (const IIS::TimedState*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IIS::TimedState*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IIS_mTimedState,
                    _0RL_IIS_mTimedState_unmarshal_fn,
                    _0RL_IIS_mTimedState_marshal_fn,
                    _0RL_IIS_mTimedState_destructor_fn,
                    _v)) {
    _sp = (const IIS::TimedState*)_v;
    return 1;
  }
  return 0;
}

